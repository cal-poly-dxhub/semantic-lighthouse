{
  "Comment": "A state machine that converts videos using MediaConvert (with chunking support), transcribes all audio chunks, and processes the merged result.",
  "StartAt": "ProcessWithMediaConvert",
  "States": {
    "ProcessWithMediaConvert": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${MediaConvertLambdaArn}",
        "Payload": {
          "inputBucket.$": "$.detail.bucket.name",
          "inputKey.$": "$.detail.object.key",
          "outputBucket": "${OutputBucketName}",
          "outputKeyPrefix": "converted/"
        }
      },
      "ResultPath": "$.mediaConvertResult",
      "Next": "CheckJobCount",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 30,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "MediaConvertFailed"
        }
      ]
    },
    "CheckJobCount": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.mediaConvertResult.Payload.job_ids",
          "IsPresent": true,
          "Next": "HasJobs"
        }
      ],
      "Default": "MediaConvertFailed"
    },
    "HasJobs": {
      "Type": "Choice",
      "Choices": [
        {
          "And": [
            {
              "Variable": "$.mediaConvertResult.Payload.job_ids",
              "IsPresent": true
            },
            {
              "Variable": "$.mediaConvertResult.Payload.job_ids[0]",
              "IsPresent": true
            }
          ],
          "Next": "WaitForMediaConvert"
        }
      ],
      "Default": "MediaConvertFailed"
    },
    "WaitForMediaConvert": {
      "Type": "Wait",
      "Seconds": 120,
      "Next": "CheckAllMediaConvertJobsWithLambda"
    },
    "CheckAllMediaConvertJobsWithLambda": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${VerifyS3FileLambdaArn}",
        "Payload": {
          "job_ids.$": "$.mediaConvertResult.Payload.job_ids"
        }
      },
      "ResultPath": "$.mediaConvertJobsCheck",
      "Next": "EvaluateMediaConvertResults",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 30,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "MediaConvertFailed"
        }
      ]
    },
    "EvaluateMediaConvertResults": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.mediaConvertJobsCheck.Payload.anyFailed",
          "BooleanEquals": true,
          "Next": "MediaConvertFailed"
        },
        {
          "Variable": "$.mediaConvertJobsCheck.Payload.allComplete",
          "BooleanEquals": true,
          "Next": "VerifyAllAudioFiles"
        }
      ],
      "Default": "WaitLongerForMediaConvert"
    },
    "WaitLongerForMediaConvert": {
      "Type": "Wait",
      "Seconds": 180,
      "Next": "CheckAllMediaConvertJobsWithLambda"
    },
    "VerifyAllAudioFiles": {
      "Type": "Map",
      "ItemsPath": "$.mediaConvertResult.Payload.audioOutputUris",
      "MaxConcurrency": 5,
      "Iterator": {
        "StartAt": "VerifySingleAudioFile",
        "States": {
          "VerifySingleAudioFile": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${VerifyS3FileLambdaArn}",
              "Payload": {
                "s3_uri.$": "$"
              }
            },
            "Next": "CheckAudioExists",
            "Retry": [
              {
                "ErrorEquals": ["States.TaskFailed"],
                "IntervalSeconds": 15,
                "MaxAttempts": 8,
                "BackoffRate": 2
              }
            ]
          },
          "CheckAudioExists": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.Payload.exists",
                "BooleanEquals": true,
                "Next": "AudioExists"
              }
            ],
            "Default": "AudioMissing"
          },
          "AudioExists": {
            "Type": "Pass",
            "Result": {
              "status": "EXISTS"
            },
            "End": true
          },
          "AudioMissing": {
            "Type": "Fail",
            "Cause": "Audio File Not Found",
            "Error": "One or more audio files generated by MediaConvert could not be found in S3."
          }
        }
      },
      "ResultPath": "$.audioVerificationResults",
      "Next": "StartAllTranscriptionJobs",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "AudioFileNotFound"
        }
      ]
    },
    "StartAllTranscriptionJobs": {
      "Type": "Map",
      "ItemsPath": "$.mediaConvertResult.Payload.audioOutputUris",
      "MaxConcurrency": 5,
      "Iterator": {
        "StartAt": "StartSingleTranscriptionJob",
        "States": {
          "StartSingleTranscriptionJob": {
            "Type": "Task",
            "Resource": "arn:aws:states:::aws-sdk:transcribe:startTranscriptionJob",
            "Parameters": {
              "LanguageCode": "en-US",
              "Media": {
                "MediaFileUri.$": "$"
              },
              "TranscriptionJobName.$": "States.Format('transcribe-{}-{}', $$.Execution.Name, States.UUID())",
              "OutputBucketName": "${OutputBucketName}",
              "OutputKey": "transcripts/",
              "Settings": {
                "ShowSpeakerLabels": true,
                "MaxSpeakerLabels": 10
              }
            },
            "Next": "WaitForSingleTranscription",
            "Retry": [
              {
                "ErrorEquals": ["States.TaskFailed"],
                "IntervalSeconds": 30,
                "MaxAttempts": 3,
                "BackoffRate": 2
              }
            ]
          },
          "WaitForSingleTranscription": {
            "Type": "Wait",
            "Seconds": 60,
            "Next": "GetSingleTranscriptionStatus"
          },
          "GetSingleTranscriptionStatus": {
            "Type": "Task",
            "Resource": "arn:aws:states:::aws-sdk:transcribe:getTranscriptionJob",
            "Parameters": {
              "TranscriptionJobName.$": "$.TranscriptionJob.TranscriptionJobName"
            },
            "Next": "CheckTranscriptionStatus"
          },
          "CheckTranscriptionStatus": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.TranscriptionJob.TranscriptionJobStatus",
                "StringEquals": "COMPLETED",
                "Next": "TranscriptionComplete"
              },
              {
                "Variable": "$.TranscriptionJob.TranscriptionJobStatus",
                "StringEquals": "FAILED",
                "Next": "TranscriptionJobFailed"
              }
            ],
            "Default": "WaitForSingleTranscription"
          },
          "TranscriptionComplete": {
            "Type": "Pass",
            "End": true
          },
          "TranscriptionJobFailed": {
            "Type": "Fail",
            "Cause": "Transcription Job Failed",
            "Error": "One or more AWS Transcribe jobs failed to complete."
          }
        }
      },
      "ResultPath": "$.transcriptionResults",
      "Next": "CheckForAgenda",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "TranscriptionFailed"
        }
      ]
    },
    "CheckForAgenda": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${VerifyS3FileLambdaArn}",
        "Payload": {
          "check_agenda": true,
          "video_s3_key.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.agendaCheck",
      "Next": "HasAgenda",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 10,
          "MaxAttempts": 2,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "ProcessAllTranscripts"
        }
      ]
    },
    "HasAgenda": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.agendaCheck.Payload.agenda_exists",
          "BooleanEquals": true,
          "Next": "ProcessAllTranscripts"
        },
        {
          "Variable": "$.agendaCheck.Payload.agenda_exists",
          "BooleanEquals": false,
          "Next": "WaitForAgenda"
        }
      ],
      "Default": "ProcessAllTranscripts"
    },
    "WaitForAgenda": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "CheckForAgendaRetry1"
    },
    "CheckForAgendaRetry1": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${VerifyS3FileLambdaArn}",
        "Payload": {
          "check_agenda": true,
          "video_s3_key.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.agendaCheckRetry",
      "Next": "AgendaFoundAfterWait1",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 10,
          "MaxAttempts": 2,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "ProcessAllTranscripts"
        }
      ]
    },
    "AgendaFoundAfterWait1": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.agendaCheckRetry.Payload.agenda_exists",
          "BooleanEquals": true,
          "Next": "ProcessAllTranscripts"
        }
      ],
      "Default": "WaitForAgenda2"
    },
    "WaitForAgenda2": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "CheckForAgendaRetry2"
    },
    "CheckForAgendaRetry2": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${VerifyS3FileLambdaArn}",
        "Payload": {
          "check_agenda": true,
          "video_s3_key.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.agendaCheckRetry",
      "Next": "AgendaFoundAfterWait2",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 10,
          "MaxAttempts": 2,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "ProcessAllTranscripts"
        }
      ]
    },
    "AgendaFoundAfterWait2": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.agendaCheckRetry.Payload.agenda_exists",
          "BooleanEquals": true,
          "Next": "ProcessAllTranscripts"
        }
      ],
      "Default": "WaitForAgenda3"
    },
    "WaitForAgenda3": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "CheckForAgendaRetry3"
    },
    "CheckForAgendaRetry3": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${VerifyS3FileLambdaArn}",
        "Payload": {
          "check_agenda": true,
          "video_s3_key.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.agendaCheckRetry",
      "Next": "AgendaFoundAfterWait3",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 10,
          "MaxAttempts": 2,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "ProcessAllTranscripts"
        }
      ]
    },
    "AgendaFoundAfterWait3": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.agendaCheckRetry.Payload.agenda_exists",
          "BooleanEquals": true,
          "Next": "ProcessAllTranscripts"
        }
      ],
      "Default": "WaitForAgenda4"
    },
    "WaitForAgenda4": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "CheckForAgendaRetry4"
    },
    "CheckForAgendaRetry4": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${VerifyS3FileLambdaArn}",
        "Payload": {
          "check_agenda": true,
          "video_s3_key.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.agendaCheckRetry",
      "Next": "AgendaFoundAfterWait4",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 10,
          "MaxAttempts": 2,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "ProcessAllTranscripts"
        }
      ]
    },
    "AgendaFoundAfterWait4": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.agendaCheckRetry.Payload.agenda_exists",
          "BooleanEquals": true,
          "Next": "ProcessAllTranscripts"
        }
      ],
      "Default": "WaitForAgenda5"
    },
    "WaitForAgenda5": {
      "Type": "Wait",
      "Seconds": 60,
      "Next": "CheckForAgendaFinal"
    },
    "CheckForAgendaFinal": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${VerifyS3FileLambdaArn}",
        "Payload": {
          "check_agenda": true,
          "video_s3_key.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.agendaCheckRetry",
      "Next": "ProcessAllTranscripts",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 10,
          "MaxAttempts": 2,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "ProcessAllTranscripts"
        }
      ]
    },
    "ProcessAllTranscripts": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${ProcessTranscriptLambdaArn}",
        "Payload": {
          "transcriptionResults.$": "$.transcriptionResults",
          "mediaConvertResult.$": "$.mediaConvertResult",
          "originalVideoInfo": {
            "bucket.$": "$.detail.bucket.name",
            "key.$": "$.detail.object.key"
          },
          "isChunkedProcessing": true,
          "agendaData.$": "$.agendaCheck.Payload"
        }
      },
      "ResultPath": "$.processResult",
      "Next": "ConvertHtmlToPdf",
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "TranscriptionProcessingFailed"
        }
      ]
    },
    "ConvertHtmlToPdf": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${HtmlToPdfFunctionArn}",
        "Payload": {
          "htmlS3Uri.$": "$.processResult.Payload.htmlS3Uri",
          "outputFileName.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.convertPdfResult",
      "Next": "SendEmailNotification",
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 30,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "TranscriptionProcessingFailed"
        }
      ]
    },
    "SendEmailNotification": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${EmailSenderLambdaArn}",
        "Payload": {
          "htmlS3Uri.$": "$.processResult.Payload.htmlS3Uri",
          "pdfS3Uri.$": "$.convertPdfResult.Payload.pdfS3Uri",
          "originalFileName.$": "$.detail.object.key"
        }
      },
      "ResultPath": "$.emailResult",
      "End": true,
      "Retry": [
        {
          "ErrorEquals": ["States.TaskFailed"],
          "IntervalSeconds": 30,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "EmailNotificationFailed"
        }
      ]
    },
    "MediaConvertFailed": {
      "Type": "Fail",
      "Cause": "MediaConvert Job Failed",
      "Error": "The MediaConvert job failed to complete successfully."
    },
    "AudioFileNotFound": {
      "Type": "Fail",
      "Cause": "Audio File Not Found",
      "Error": "One or more audio files generated by MediaConvert could not be found in S3."
    },
    "TranscriptionFailed": {
      "Type": "Fail",
      "Cause": "Transcription Job Failed",
      "Error": "One or more AWS Transcribe jobs failed to complete."
    },
    "TranscriptionProcessingFailed": {
      "Type": "Fail",
      "Cause": "Transcript Processing Failed",
      "Error": "The transcript processing and analysis failed to complete."
    },
    "EmailNotificationFailed": {
      "Type": "Fail",
      "Cause": "Email Notification Failed",
      "Error": "Failed to send email notification to user."
    }
  }
}
